package com.e.tracker.support.trackToFile

import android.app.Application
import android.os.Environment
import androidx.core.os.EnvironmentCompat
import androidx.lifecycle.AndroidViewModel
import com.e.tracker.database.TrackCoordModel
import com.e.tracker.database.TrackDatabase
import com.e.tracker.database.TrackModel
import kotlinx.coroutines.*
import java.io.File
import java.lang.Exception
import java.time.format.DateTimeFormatter
//import org.joda.time.DateTime
//import org.joda.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatter.ofPattern
import java.util.*
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.Transformer
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult

/**
 * Save track as gpx file
 *
 */
class TrackToGpx(trackId: Long, application: Application) : AndroidViewModel(application) {

    private var osmActivityJob = Job()
    private var uiScope = CoroutineScope(Dispatchers.Main + osmActivityJob)

    init {
        println("TrackToGpx")

        val dataSource = TrackDatabase.getInstance(application).trackDatabaseDao
        val coordsSource = TrackDatabase.getInstance(application).trackCoordDatabaseDao

        uiScope.launch {
            withContext(Dispatchers.IO) {
                val trackToSave = dataSource.get(trackId)

                if (trackToSave != null) {
                    println("TrackToSave name: ${trackToSave.trackName}")

                    val coords = coordsSource.getCoordsForId(trackId)
                    val trackXml = makeXml(trackToSave, coords)

                    val trackXmlAsString = trackXml.toString()
                    println(trackXmlAsString)

                    var pathToDir = getPathToMyTracks()
                    if (pathToDir != null) {
                        pathToDir = "$pathToDir/${trackToSave.trackName}.gpx"

                        try {
                            File(pathToDir).writeText(trackXmlAsString)
                        } catch (e: Error)  {
                            println("Error: $e")
                        }
                    }

                }
            }

        }
    }

    private fun makeXml(track: TrackModel, coords: List<TrackCoordModel>) : Node {
        val t = xml( root = "gpx", encoding = "UTF-8", version = XmlVersion.V10) {
            attributes(Pair("xmlns", "http://www.topografix.com/GPX/1/1"))
            attributes(Pair(" xmlns:gpxx", "http://www.garmin.com/xmlschemas/GpxExtensions/v3"))
            attributes(Pair("xmlns:rcxx", "http://www.routeconverter.de/xmlschemas/RouteCatalogExtensions/1.0"))
            attributes(Pair("version", "1.1"))
            attributes(Pair("creator", "Generated by Tracker@vw"))
//            "gpx" {
//                attributes(Pair("xmlns", "http://www.topografix.com/GPX/1/1"))
//                attributes(Pair(" xmlns:gpxx", "http://www.garmin.com/xmlschemas/GpxExtensions/v3"))
//                attributes(Pair("xmlns:rcxx", "http://www.routeconverter.de/xmlschemas/RouteCatalogExtensions/1.0"))
//                attributes(Pair("version", "1.1"))
//                attributes(Pair("creator", "Generated by Tracker@vw"))
//            }
            //xmlns = "http://www.topografix.com/GPX/1/1"

            "trk" {
                "name" { -track.trackName}
                "desc" { -track.trackDescription}
                "trkseg" {
                    for (coord in coords ) {
                        "trkpt" {
                            attributes(Pair("lon", coord.longitude))
                            attributes(Pair("lat", coord.latitude))

                            "ele" { -altitudeCheck(coord.altitude).toString() }

                        }
                    }
                }

            }

//            "metadata" {
//                "name" {
//                    -track.trackName
//                }
//            }
//            // end metadata
//
//            for (coord in coords) {
//                "wpt" {
//                    attributes(Pair("lon", coord.longitude))
//                    attributes(Pair("lat", coord.longitude))
//
//                    "ele" { -altitudeCheck(coord.altitude).toString() }
//                    "name" { -createdAtCheck(coord.createdAt) }
//                }
//            }
            // wpt's


        }

        return t
    }


    private fun altitudeCheck(altitude: Double?) : Double {
        if (altitude != null) {
            return altitude
        }
        return 0.0
    }


    private fun createdAtCheck(date: Date?) : String {
        if (date != null) {
            //var formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy")
            return date.toString()
        }

        return "0.0.0"
    }

    /**
     * Return path to directory MyTracks on sdcard.
     * Create directory if not exist
     */
    private fun getPathToMyTracks() : String? {
        if (EnvironmentCompat.getStorageState(Environment.getExternalStorageDirectory()) == "mounted") {
            val extSdCard = Environment.getExternalStorageDirectory().absolutePath

            if (extSdCard != null) {
                val pathToMyTracks = "$extSdCard/MyTracks"

                if (!File(pathToMyTracks).exists()) {
                   val mkdirResult = File(pathToMyTracks).mkdir()
                    if (!mkdirResult) {
                        return null
                    }
                }
                return pathToMyTracks
            }
        }

        return null
    }
}